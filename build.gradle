plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.3.0'
    id 'edu.wpi.first.GradleRIO' version '2019.0.0-alpha-3'
    id 'jacoco'
}

repositories {
    mavenCentral()
}

dependencies {
    compile 'org.jetbrains.kotlin:kotlin-stdlib'

    compile wpilib()
    compile ctre()

    testCompile 'junit:junit:4.12'
    testCompile 'org.powermock:powermock:1.6.6'
    testCompile 'org.powermock:powermock-module-junit4:1.6.6'
    testCompile 'org.powermock:powermock-api-mockito:1.6.6'
}

/* Begin GradleRIO */

    def ROBOT_CLASS = 'frc.team5499.frc2018Kotlin.Robot'

    deploy {
        targets {
            target('roborio', edu.wpi.first.gradlerio.frc.RoboRIO) {
                team = getTeamOrDefault(5499)
            }
        }
        artifacts {
            artifact('frcKotlin', edu.wpi.first.gradlerio.frc.FRCJavaArtifact) {
                targets << 'roborio'
                debug = getDebugOrDefault(false)
            }
        }
    }

    jar {
        from configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
        manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_CLASS)
    }

/* End GradleRIO */
/* Begin JUnit */

    test {
        dependsOn 'cleanTest'

        testLogging {
            exceptionFormat = 'full'
        }

        afterSuite { desc, result ->
            if (!desc.parent) {
                println "\nTest result: ${result.resultType}"
                println "Test summary: ${result.testCount} tests, " +
                        "${result.successfulTestCount} succeeded, " +
                        "${result.failedTestCount} failed, " +
                        "${result.skippedTestCount} skipped"
            }
        }
    }


/* End JUint */
/* Begin Codecov */

    jacoco {
        toolVersion = '0.8.2'
    }

    jacocoTestReport {
        reports {
            xml.enabled true
            html.enabled true
        }
    }

    // We have to do offline instrumentation to make powermock and jacoco play nice
    project.ext.jacocoOfflineSourceSets = ['main']

    task instrument(dependsOn: [classes, project.configurations.jacocoAnt]) {
        inputs.files classes.outputs.files
        File outputDir = new File(project.buildDir, 'instrumentedClasses')
        outputs.dir outputDir
        doFirst {
            project.delete(outputDir)
            ant.taskdef(
                    resource: 'org/jacoco/ant/antlib.xml',
                    classpath: project.configurations.jacocoAnt.asPath,
                    uri: 'jacoco'
            )
            def instrumented = false
            jacocoOfflineSourceSets.each { sourceSetName ->
                if (file("${buildDir}/classes/kotlin/${sourceSetName}").exists()) {
                    def instrumentedClassedDir = "${outputDir}/${sourceSetName}"
                    ant.'jacoco:instrument'(destdir: instrumentedClassedDir) {
                        fileset(dir: "${buildDir}/classes/kotlin/${sourceSetName}", includes: '**/*.class')
                    }
                    //Replace the classes dir in the test classpath with the instrumented one
                    sourceSets.test.runtimeClasspath -= files("${buildDir}/classes/kotlin/${sourceSetName}")
                    sourceSets.test.runtimeClasspath += files(instrumentedClassedDir)
                    instrumented = true
                }
            }
            if (instrumented) {
                //Disable class verification based on https://github.com/jayway/powermock/issues/375
                test.jvmArgs += '-noverify'
            }
        }
    }

    test.dependsOn 'instrument'

/* End Codecov */
/* Begin Tox */

    task tox {
        doLast {
            exec {
                executable 'tox'
            }
        }
    }

    test.finalizedBy 'tox'

    // Alias tox as 'install_hooks'
    task install_hooks(dependsOn: 'tox')

/* End Tox */
